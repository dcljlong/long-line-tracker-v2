import React, { createContext, useContext, useEffect, useCallback, useState } from 'react';
import { supabase } from '@/lib/supabase';
import type { UserProfile, UserRole } from '@/types';

interface AuthState {
  user: UserProfile | null;
  isAuthenticated: boolean;
  isAdmin: boolean;
  isLoading: boolean;
  error: string | null;
}

interface AuthContextType extends AuthState {
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string, fullName: string, role?: UserRole) => Promise<void>;
  signOut: () => Promise<void>;
  clearError: () => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

async function withTimeout<T>(p: Promise<T>, ms: number, label: string): Promise<T> {
  let t: any;
  const timeout = new Promise<never>((_, rej) => {
    t = setTimeout(() => rej(new Error(`${label} timed out after ${ms}ms`)), ms);
  });
  try {
    return await Promise.race([p, timeout]);
  } finally {
    clearTimeout(t);
  }
}

async function fetchProfile(userId: string): Promise<UserProfile | null> {
  const { data, error } = await supabase
    .from('profiles')
    .select('*')
    .eq('user_id', userId)
    .maybeSingle();

  if (error) throw error;
  return data ?? null;
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<AuthState>({
    user: null,
    isAuthenticated: false,
    isAdmin: false,
    isLoading: true,
    error: null,
  });

  useEffect(() => {
    let cancelled = false;

    const setUnauthed = () => {
      if (cancelled) return;
      setState({
        user: null,
        isAuthenticated: false,
        isAdmin: false,
        isLoading: false,
        error: null,
      });
    };

    const setAuthed = (profile: UserProfile) => {
      if (cancelled) return;
      setState({
        user: profile,
        isAuthenticated: true,
        isAdmin: profile.role === 'admin',
        isLoading: false,
        error: null,
      });
    };

    const init = async () => {
      try {
        const res = await withTimeout(supabase.auth.getSession(), 45000, 'auth.getSession');
        const session = res?.data?.session;

        if (!session?.user?.id) {
          setUnauthed();
          return;
        }

        // Load profile; if missing, fall back to minimal user object so the app can proceed.
        try {
          const profile = await withTimeout(fetchProfile(session.user.id), 45000, 'profiles.select');
          if (profile) {
            setAuthed(profile);
            return;
          }
        } catch (e: any) {
          console.error('Profile fetch error:', e?.message || e);
        }

        // Minimal fallback so UI is usable even if profiles table/RLS is misconfigured.
        setAuthed({
          id: session.user.id,
          user_id: session.user.id,
          email: session.user.email || '',
          full_name: session.user.user_metadata?.full_name || session.user.email || '',
          role: 'admin' as any,
          created_at: new Date().toISOString(),
        } as UserProfile);
      } catch (e: any) {
        console.error('Auth init error:', e?.message || e);
        setUnauthed();
      }
    };

    init();

    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {
      try {
        if (event === 'SIGNED_OUT' || !session?.user?.id) {
          setUnauthed();
          return;
        }

        // Show loading while switching auth state
        if (!cancelled) setState(prev => ({ ...prev, isLoading: true, error: null }));

        // Try profile
        try {
          const profile = await withTimeout(fetchProfile(session.user.id), 45000, 'profiles.select');
          if (profile) {
            setAuthed(profile);
            return;
          }
        } catch (e: any) {
          console.error('Profile fetch error (onAuthStateChange):', e?.message || e);
        }

        // Minimal fallback
        setAuthed({
          id: session.user.id,
          user_id: session.user.id,
          email: session.user.email || '',
          full_name: session.user.user_metadata?.full_name || session.user.email || '',
          role: 'admin' as any,
          created_at: new Date().toISOString(),
        } as UserProfile);
      } catch (e: any) {
        console.error('Auth state change error:', e?.message || e);
        setState(prev => ({ ...prev, isLoading: false, error: e?.message || 'Auth error' }));
      }
    });

    return () => {
      cancelled = true;
      subscription.unsubscribe();
    };
  }, []);

  const signIn = useCallback(async (email: string, password: string) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const { error } = await withTimeout(
        supabase.auth.signInWithPassword({ email, password }),
        12000,
        'auth.signInWithPassword'
      );
      if (error) throw error;
      // onAuthStateChange will set final state
    } catch (e: any) {
      setState(prev => ({ ...prev, isLoading: false, error: e?.message || 'Sign-in failed' }));
    }
  }, []);

  const signUp = useCallback(async (email: string, password: string, fullName: string, role: UserRole = 'standard') => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const { data, error } = await withTimeout(
        supabase.auth.signUp({ email, password, options: { data: { full_name: fullName } } }),
        12000,
        'auth.signUp'
      );
      if (error) throw error;

      // Create profile row immediately (best effort)
      if (data.user?.id) {
        await supabase.from('profiles').upsert({
          user_id: data.user.id,
          email,
          full_name: fullName,
          role,
        });
      }

      // onAuthStateChange will set final state
    } catch (e: any) {
      setState(prev => ({ ...prev, isLoading: false, error: e?.message || 'Sign-up failed' }));
    }
  }, []);

  const signOut = useCallback(async () => {
    await supabase.auth.signOut();
  }, []);

  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }));
  }, []);

  return (
    <AuthContext.Provider value={{ ...state, signIn, signUp, signOut, clearError }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within AuthProvider');
  return ctx;
}

